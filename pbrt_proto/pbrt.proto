syntax = "proto2";

package pbrt_proto;

//
// Common Data Types
//

// A blackbody spectral power distribution.
message BlackbodySpectrum {
  // The temperature of the emitter in Kelvin.
  required double temperature = 1;

  // A scale applied to the intensity of the spectrum.
  //
  // NOTE: For simplicity, this type is shared between all PBRT versions;
  //       however, it's semantics change starting with PBRTv4. In earlier
  //       versions this parameter is required and in later versions should
  //       be ignored.
  optional double scale = 2 [default = 1.0];
}

// A sub-region of the image to render in pixel coordinates.
message PixelBounds {
  // The lower `x` bound of the region.
  required uint32 x_min = 1;

  // The upper `x` bound of the region.
  required uint32 x_max = 2;

  // The lower `y` bound of the region.
  required uint32 y_min = 3;

  // The upper `y` bound of the region.
  required uint32 y_max = 4;
}

// A coordinate in 3D space.
message Point {
  // The `x` component of the coordinate.
  required double x = 1;

  // The `y` component of the coordinate.
  required double y = 2;
  
  // The `z` component of the coordinate.
  required double z = 3;
}

// A spectral power distribution represented by an RGB color.
message RgbSpectrum {
  // The `r` component of the color.
  required double r = 1;

  // The `g` component of the color.
  required double g = 2;

  // The `b` component of the color.
  required double b = 3;
}

// A spectral power distribution represented by list of samples.
message SampledSpectrum {
  // A single sample of the spectrum's SPD.
  message Sample {
    // The wavelength of the sample.
    required double wavelength = 1;

    // The intensity of the sample.
    required double intensity = 2;
  }

  // All of the samples in the spectrum.
  repeated Sample samples = 1;
}

// A spectral power distribution represented by an XYZ color.
message XyzSpectrum {
  // The `x` component of the color.
  required double x = 1;

  // The `x` component of the color.
  required double y = 2;

  // The `x` component of the color.
  required double z = 3;
}

// A direction in 3D space
message Vector {
  // The `x` component of the direction.
  required double x = 1;

  // The `y` component of the direction.
  required double y = 2;

  // The `z` component of the direction.
  required double z = 3;
}

//
// Common Variant Data Types
//

// A spectral power distribution
message Spectrum {
  oneof spectrum_type {
    // A spectral power distribution with a constant value at all wavelengths.
    //
    // NOTE: There is no way to directly specify such a spectrum in PBRT. This
    //       type is only used for expressing default values.
    double constant_spectrum = 1;

    // A spectral power distribution with a blackbody spectrum.
    BlackbodySpectrum blackbody_spectrum = 2;

    // A spectral power distribution created out of an RGB tuple.
    //
    // NOTE: How to determine the color space of this tuple depends on the PBRT
    //       version.
    RgbSpectrum rgb_spectrum = 3;

    // A spectral power distribution created out of an XYZ tuple.
    XyzSpectrum xyz_spectrum = 4;

    // A spectral power distribution formed from individual spectral samples
    // that are specified inline.
    SampledSpectrum sampled_spectrum = 5;

    // A spectral power distribution formed from individual spectral samples
    // that are specified in the referenced file.
    string sampled_spectrum_filename = 6;
  }
}

// A floating point parameter to a texture.
message FloatTextureParameter {
  oneof float_texture_parameter_type {
    // A constant floating point value.
    double float_value = 1;

    // The name of an already defined floating point texture.
    string float_texture_name = 2;
  }
}

// A spectral point parameter to a texture.
message SpectrumTextureParameter {
  oneof spectrum_texture_parameter_type {
    // A spectral power distribution with a constant value at all wavelengths.
    //
    // NOTE: There is no way to directly specify such a spectrum in PBRT. This
    //       type is only used for expressing default values.
    double constant_spectrum = 1;

    // A spectral power distribution with a blackbody spectrum.
    BlackbodySpectrum blackbody_spectrum = 2;

    // A spectral power distribution created out of an RGB tuple.
    //
    // NOTE: How to determine the color space of this tuple depends on the PBRT
    //       version.
    RgbSpectrum rgb_spectrum = 3;

    // A spectral power distribution created out of an XYZ tuple.
    XyzSpectrum xyz_spectrum = 4;

    // A spectral power distribution formed from individual spectral samples
    // that are specified inline.
    SampledSpectrum sampled_spectrum = 5;

    // A spectral power distribution formed from individual spectral samples
    // that are specified in the referenced file.
    string sampled_spectrum_filename = 6;

    // The name of an already defined spectrum texture.
    string spectrum_texture_name = 7;
  }
}

//
// Common Directives
//

// A directive that selects the current transformation matrix
message ActiveTransform {
  // The available transformation matrices.
  enum ActiveTransformation {
    ALL = 1;
    START_TIME = 2;
    END_TIME = 3;
  };

  // The selected transformation matrix.
  required ActiveTransformation active = 1 [default = ALL];
}

// A directive which pushes the current graphics state including the current
// transformation matrix and the reverse-orientation setting to the attribute
// stack.
message AttributeBegin {}

// A directive which pops the attribute stack and restores the saved graphics
// state. If the stack is empty, the program should exit with an error.
message AttributeEnd {}

// A directive which multiplies the current transformation matrix by the matrix
// specified.
message ConcatTransform {
  // The m[0][0] component of the matrix with column-major order.
  required double m00 = 1;

  // The m[0][1] component of the matrix with column-major order.
  required double m01 = 2;

  // The m[0][2] component of the matrix with column-major order.
  required double m02 = 3;

  // The m[0][3] component of the matrix with column-major order.
  required double m03 = 4;

  // The m[1][0] component of the matrix with column-major order.
  required double m10 = 5;

  // The m[1][1] component of the matrix with column-major order.
  required double m11 = 6;

  // The m[1][2] component of the matrix with column-major order.
  required double m12 = 7;

  // The m[1][3] component of the matrix with column-major order.
  required double m13 = 8;

  // The m[2][0] component of the matrix with column-major order.
  required double m20 = 9;

  // The m[2][1] component of the matrix with column-major order.
  required double m21 = 10;

  // The m[2][2] component of the matrix with column-major order.
  required double m22 = 11;

  // The m[2][3] component of the matrix with column-major order.
  required double m23 = 12;

  // The m[3][0] component of the matrix with column-major order.
  required double m30 = 13;

  // The m[3][1] component of the matrix with column-major order.
  required double m31 = 14;

  // The m[3][2] component of the matrix with column-major order.
  required double m32 = 15;

  // The m[3][3] component of the matrix with column-major order.
  required double m33 = 16;
}

// A directive which saves the current transformation matrix using the
// specified name.
message CoordinateSystem {
  // The name to give the saved transformation.
  required string name = 1;
}

// A directive which sets the current transformation matrix to a previously
// saved matrix. If no matrix matches the provided name the directive has no
// effect.
message CoordSysTransform {
  // The name of the saved transformation to restore.
  required string name = 1;
}

// A directive which sets the current transformation matrix to the identity
// matrix.
message Identity {}

// A directive which opens a file and continues parsing from the start of it.
// Mimics the semantics of the C `#include` preprocessor directive.
//
// NOTE: This directive cannot fully capture the semantics of the PBRT Include
//       directive since it must be a standalone directive and cannot be used
//       as part of a separate directive.
message Include {
  // The relative path to the file to include.
  required string path = 1;
}

// A directive which opens a file and parses it in a separate parsing context
// that inherits the scene-wide state of the renderer.
message Import {
  // The relative path to the file to import.
  required string path = 1;
}

// A directive which sets the current material to a previously saved material.
// If no material matches the provided name the directive has no effect.
message NamedMaterial {
  // The name of the saved material to restore.
  required string name = 1;
}

// A directive which multiplies the current transformation matrix by the inverse
// of the specified camera matrix.
message LookAt {
  // The `x` component of the camera location.
  required double eye_x = 1;

  // The `y` component of the camera location.
  required double eye_y = 2;

  // The `z` component of the camera location.
  required double eye_z = 3;

  // The `x` component of the point the camera faces.
  required double look_x = 4;

  // The `y` component of the point the camera faces.
  required double look_y = 5;

  // The `z` component of the point the camera faces.
  required double look_z = 6;

  // The `x` component of the up direction for the camera.
  required double up_x = 7;

  // The `y` component of the up direction for the camera.
  required double up_y = 8;

  // The `z` component of the up direction for the camera.
  required double up_z = 9;
}

// A directive which specifies the current interior and exterior participating
// media.
message MediumInterface {
  // The interior medium. If empty, there is no medium.
  required string inside = 1;

  // The exterior medium. If empty, there is no medium.
  required string outside = 2;
}

// A directive which begins creating an instanced object with the specified
// name.
message ObjectBegin {
  // The name to give the indexed object.
  required string name = 1;
}

// A directive finalizes the creation of an instanced object.
message ObjectEnd {}

// A directive which adds a previously instanced object to the scene. If no
// object matching the name is found, this directive is ignored.
message ObjectInstance {
  // The name of the instanced object to draw.
  required string name = 1;
}

// A directive which reverses the front and back faces of geometry.
message ReverseOrientation {}

// A directive which multiplies the current transformation matrix by the
// specified rotation matrix.
message Rotate {
  // The angle of the rotation in degrees.
  required double angle = 1;

  // The `x` component of the vector about which the rotation occurs.
  required double x = 2;

  // The `y` component of the vector about which the rotation occurs.
  required double y = 3;

  // The `z` component of the vector about which the rotation occurs.
  required double z = 4;
}

// A directive which multiplies the current transformation matrix by the
// specified scalar matrix.
message Scale {
  // The `x` component of the magnitude of the scale.
  required double x = 1;

  // The `y` component of the magnitude of the scale.
  required double y = 2;

  // The `z` component of the magnitude of the scale.
  required double z = 3;
}

// A directive which multiplies the current transformation matrix by the
// specified matrix.
message Transform {
  // The m[0][0] component of the matrix with column-major order.
  required double m00 = 1;

  // The m[0][1] component of the matrix with column-major order.
  required double m01 = 2;

  // The m[0][2] component of the matrix with column-major order.
  required double m02 = 3;

  // The m[0][3] component of the matrix with column-major order.
  required double m03 = 4;

  // The m[1][0] component of the matrix with column-major order.
  required double m10 = 5;

  // The m[1][1] component of the matrix with column-major order.
  required double m11 = 6;

  // The m[1][2] component of the matrix with column-major order.
  required double m12 = 7;

  // The m[1][3] component of the matrix with column-major order.
  required double m13 = 8;

  // The m[2][0] component of the matrix with column-major order.
  required double m20 = 9;

  // The m[2][1] component of the matrix with column-major order.
  required double m21 = 10;

  // The m[2][2] component of the matrix with column-major order.
  required double m22 = 11;

  // The m[2][3] component of the matrix with column-major order.
  required double m23 = 12;

  // The m[3][0] component of the matrix with column-major order.
  required double m30 = 13;

  // The m[3][1] component of the matrix with column-major order.
  required double m31 = 14;

  // The m[3][2] component of the matrix with column-major order.
  required double m32 = 15;

  // The m[3][3] component of the matrix with column-major order.
  required double m33 = 16;
}

// A directive which pushes the current transformation matrix to the
// transformation stack.
message TransformBegin {}

// A directive which pops the transformation stack and sets the current
// transformation matrix to its contents. If the stack is empty, the program
// should exit with an error.
message TransformEnd {}

// A directive which sets the start and end times for animations in the rendered
// scene.
message TransformTimes {
  // The time at which rendering begins.
  required double start_time = 1;

  // The time at which rendering ends.
  required double end_time = 2;
}

// A directive which multiplies the current transformation matrix by the
// specified translation matrix.
message Translate {
  // The `x` component of the magnitude of the translation.
  required double x = 1;

  // The `y` component of the magnitude of the translation.
  required double y = 2;

  // The `z` component of the magnitude of the translation.
  required double z = 3;
}

// A directive which marks the beginning of the scene geometry.
message WorldBegin {}

// A directive which triggers rendering then resets the state of the renderer.
message WorldEnd {}

//
// Common Parameters
//

// The type of antialiasing to apply to 2D checkerboard textures
enum CheckerboardAntialiasing {
  CLOSEDFORM = 0;
  NONE_AA = 1;
}

// The type of texture wrapping to apply to 2D image textures
enum ImageWrap {
  REPEAT = 0;
  BLACK = 1;
  CLAMP = 2;
}

// The type of texture mapping to apply to 2D textures.
enum TextureMapping {
  UV = 0;
  SPHERICAL = 1;
  CYLINDRICAL = 2;
  PLANAR = 3;
}

//
// Common Accelerators
//

// A bounding volume heirarchy (BVH) accelerator.
message BvhAccelerator {
  enum SplitMethod {
    // Split each node using the surface area heuristic.
    SAH = 0;

    // Split each node node near its midpoint along the split axis.
    MIDDLE = 1;

    // Split each node so that each node contains an equal number of primitives.
    EQUAL = 2;

    // Split each node using the HLBVH construction mechanism.
    //
    // NOTE: For simplicity, this value is shared between all PBRT versions that
    //       support BVH; however, it is not supported in PBRTv2 and should be
    //       ignored when reading PBRTv2 input.
    HLBVH = 3;
  }

  // The maximum number of primitives per node for split methods other than
  // MIDDLE and EQUAL. If zero, the behavior is undefined.
  optional uint32 maxnodeprims = 1 [default = 4];

  // The method for recursively splitting the geometry into a BVH.
  optional SplitMethod splitmethod = 2 [default = SAH];
}

// A voxel-based accelerator.
message GridAccelerator {
  // If true, primitives are refined as soon as they are added to the grid.
  // Otherwise, they are refined when a ray enters the voxel that contains the
  // primitive.
  optional bool refineimmediately = 1 [default = false];
}

// A KD-tree based accelerator.
message KdTreeAccelerator {
  // The cost estimate for each intersection.
  optional double intersectcost = 1 [default = 80.0];

  // The cost estimate for each traversal.
  optional double traversalcost = 2 [default = 1.0];

  // The bonus factor to give empty nodes.
  optional double emptybonus = 3 [default = 0.5];

  // The soft maximum number of primitives per node.
  optional uint32 maxprims = 4 [default = 1];

  // The maximum depth of the tree. If zero, the choice of maximum depth is left
  // to the renderer.
  optional uint32 maxdepth = 5 [default = 0];
}

//
// Common Area Light Sources
//

// A diffuse area light source as represented from PBRTv1 through PBRTv3.
message DiffuseAreaLightSourceV1 {
  // A constant spectral power distribution describing the light. 
  optional Spectrum L = 1;

  // The suggested number of shadow samples to take from the light. May be
  // ignored depending on the Integrator used for rendering.
  //
  // NOTE: In PBRTv1 and PBRTv2 this field is referred to by the name
  //       `nsamples`; however, it is referred to here as `samples` which is the
  //       final name for the parameter that was used in PBRTv3.
  optional uint32 samples = 2 [default = 1];

  // A scale applied to the spectrum provided in `L`.
  //
  // NOTE: For simplicity, this field is shared across multiple PBRT versions;
  //       however, it is not supported in PBRTv1 and should be ignored when
  //       reading PBRTv1 input.
  optional Spectrum scale = 3;

  // If true, light should emit from both sides both side of geometry.
  //
  // NOTE: For simplicity, this field is shared across multiple PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading input from other versions.
  optional bool twosided = 4 [default = false];
}

// A diffuse area light source as represented starting from PBRTv4.
message DiffuseAreaLightSourceV2 {
  // The spectral representation for the emitter. If neither is present, the
  // the default illuminant of the current color space should be used.
  oneof spectrum_type {
    // A constant spectral power distribution describing the light.
    Spectrum L = 1;

    // The path to an image file describing the spatially-varying emissions
    // over the surface of the light.
    string filename = 2;
  }

  // A scale applied to the spectrum of the emitter.
  optional double scale = 3 [default = 1.0];

  // The desired power of the light.
  optional double power = 4 [default = -1.0];

  // If true, light should emit from both sides both side of geometry.
  optional bool twosided = 5 [default = false];
}

//
// Common Cameras
//

// The bounds of the film plane in screen space.
message CameraScreenWindow {
  // The lower x bound of the film plane.
  required double x_min = 1;

  // The upper x bound of the film plane.
  required double x_max = 2;

  // The lower y bound of the film plane.
  required double y_min = 3;

  // The upper y bound of the film plane.
  required double y_max = 4;
}

// A camera that projects an orthographic image onto the film plane.
message OrthographicCamera {
  // The time at which the shutter opens.
  optional double shutteropen = 1 [default = 0.0];

  // The time at which the shutter closes.
  optional double shutterclose = 2 [default = 1.0];

  // The radius of the lens.
  optional double lensradius = 3 [default = 0.0];

  // The focal distance of the camera.
  //
  // NOTE: The default value for this value varies by PBRT version. In PBRTv1
  //       and PBRTv2 this value defaults to `1e30`. In PBRTv3 and later the
  //       default value is `1e6`.
  optional double focaldistance = 4;

  // The aspect ratio of the film. If unspecified, this value should default to
  // the x-resolution of the film divided by the y-resolution of the film.
  optional double frameaspectratio = 5;

  // The bounds of the film plane in screen space. If unspecified, the lower
  // and upper bounds should be `[-1.0, 1.0]` along the shorter image axis and
  // set proportionally along the longer image axis.
  optional CameraScreenWindow screenwindow = 6;

  // The near clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double hither = 7;

  // The far clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double yon = 8;
}

// A camera that projects an perspective image onto the film plane.
message PerspectiveCamera {
  // The time at which the shutter opens.
  optional double shutteropen = 1 [default = 0.0];

  // The time at which the shutter closes.
  optional double shutterclose = 2 [default = 1.0];

  // The field of view of the camera in degrees.
  //
  // NOTE: In PBRTv2 and PBRTv3 there are two parameters that map into this
  //       field: `fov` and `halffov`. If `halffov` is specified in either of
  //       these versions the value of `fov` if presnent should be set to half
  //       the value of `halffov`.
  optional double fov = 3 [default = 90.0];

  // The radius of the lens.
  optional double lensradius = 4 [default = 0.0];

  // The focal distance of the camera.
  //
  // NOTE: The default value for this value varies by PBRT version. In PBRTv1
  //       and PBRTv2 this value defaults to `1e30`. In PBRTv3 and later the
  //       default value is `1e6`.
  optional double focaldistance = 5;

  // The aspect ratio of the film. If unspecified, this value should default to
  // the x-resolution of the film divided by the y-resolution of the film.
  optional double frameaspectratio = 6;

  // The bounds of the film plane in screen space. If unspecified, the lower
  // and upper bounds should be `[-1.0, 1.0]` along the shorter image axis and
  // set proportionally along the longer image axis.
  optional CameraScreenWindow screenwindow = 7;

  // The near clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double hither = 8;

  // The far clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double yon = 9;
}

// A camera which captures the light arriving at a point from all directions.
// In PBRT versions prior to PBRTv4 this type of camera was referred to as an
// environmental camera.
message SphericalCamera {
  // The mappping used from 2D points on the image to directions in 3D.
  enum Mapping {
    // A mapping in which each pixel in the output image covers an equal amount
    // of solid angle on the sphere of 3D directions based on an octrahedral
    // encoding.
    //
    // This is the default mapping in PBRTv4 and later.
    EQUALAREA = 0;

    // A mapping which each pixel in the output image covers an equal number of
    // degrees of longitude and latitude on the sphere of 3D directions.
    //
    // This is the default mapping in PBRTv1, PBRTv2, and PBRTv3.
    EQUIRECTANGULAR = 1;
  }

  // The time at which the shutter opens.
  optional double shutteropen = 1 [default = 0.0];

  // The time at which the shutter closes.
  optional double shutterclose = 2 [default = 1.0];

  // The 2D to 3D direction mapping to use for the image.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv4 and later. In earlier
  //       versions an equirectantular mapping is the only supported mapping.
  optional Mapping mapping = 3;

  // The radius of the lens.
  optional double lensradius = 4 [default = 0.0];

  // The focal distance of the camera.
  //
  // NOTE: This value has a default value of `1e30` in all PBRT versions;
  //       however, for consistency with the other cameras that default value is
  //       not specified here. 
  optional double focaldistance = 5;

  // The aspect ratio of the film. If unspecified, this value should default to
  // the x-resolution of the film divided by the y-resolution of the film.
  optional double frameaspectratio = 6;

  // The bounds of the film plane in screen space. If unspecified, the lower
  // and upper bounds should be `[-1.0, 1.0]` along the shorter image axis and
  // set proportionally along the longer image axis.
  optional CameraScreenWindow screenwindow = 7;

  // The near clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double hither = 8;

  // The far clipping plane.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported after PBRTv1 and should be ignored when
  //       reading later input.
  optional double yon = 9;
}

// A camera that simulates a ray passing through a complex lens system.
message RealisticCamera {
  // The time at which the shutter opens.
  optional double shutteropen = 1 [default = 0.0];

  // The time at which the shutter closes.
  optional double shutterclose = 2 [default = 1.0];

  // The path to a lens description file.
  //
  // NOTE: This parameter is REQUIRED. In PBRTv3 if this parameter is missing or
  //       if the file cannot be found the camera should be unset. In PBRTv4 or
  //       later if parameter is missing or the file is not found the renderer
  //       should exit with an error.
  optional string lensfile = 3 [default = ""];

  // The diameter of the aperture of the lens system in millimeters.
  optional double aperturediameter = 4 [default = 1.0];

  // The shape of the aperture. If missing, the aperture has a circular shape.
  //
  // If the value is one of "gaussian", "square", "pentagon", or "star" it
  // refers to a built-in aperture shape. Otherwise, the string references an
  // image file that describes the aperture's shape. If this file is not found
  // then the renderer should exit with an error.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional string aperture = 5;

  // The distance to which the camera is focused in meters.
  //
  // NOTE: This value has a default value of `10.0` in all PBRT versions;
  //       however, for consistency with the other cameras that default value is
  //       not specified here. 
  optional double focusdistance = 6;

  // If true, the samples are only weighted by the "cosine-to-the-4th" term.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading later input.
  optional bool simpleweighting = 7;
}

//
// Common Film
//

// The sub-region of the image to render in normalized device coordinates.
message FilmCropWindow {
  // The lower `x` bound of the region.
  required double x_min = 1 [default = 0.0];

  // The upper `x` bound of the region.
  required double x_max = 2 [default = 1.0];

  // The lower `y` bound of the region.
  required double y_min = 3 [default = 0.0];

  // The upper `y` bound of the region.
  required double y_max = 4 [default = 1.0];
}

// The type of sensor in the virtual camera.
enum FilmSensor {
  CIE_1931 = 0;
  CANON_EOS_100D = 1;
  CANON_EOS_1DX_MKII = 2;
  CANON_EOS_200D_MKII = 3;
  CANON_EOS_200D = 4;
  CANON_EOS_5D_MKII = 5;
  CANON_EOS_5D_MKIII = 6;
  CANON_EOS_5D_MKIV = 7;
  CANON_EOS_5D = 8;
  CANON_EOS_5DS = 9;
  CANON_EOS_M = 10;
  HASSELBLAD_L1D_20C = 11;
  NIKON_D810 = 12;
  NIKON_D850 = 13;
  SONY_ILCE_6400 = 14;
  SONY_ILCE_7M3 = 15;
  SONY_ILCE_7RM3 = 16;
  SONY_ILCE_9 = 17;
};

// A film which stores the rendered output as an RGB image as well as additional
// channels that can be used for denoising and ML training.
message GBufferFilm {
  // The output filename.
  optional string filename = 1 [default = "pbrt.exr"];

  // The size of the image in the `x` direction.
  optional uint32 xresolution = 2 [default = 1280];

  // The size of the image in the `y` direction.
  optional uint32 yresolution = 3 [default = 720];

  // The diagonal of the film in millimeters. Only applies if the image is
  // rendered using a realistic camera.
  optional double diagonal = 4 [default = 35.0];

  // The bounds of the crop to apply to the image. If none are specified, the
  // image is uncropped.
  oneof crop_bounds {
    // The sub-region of the image to render in normalized device coordinates.
    FilmCropWindow cropwindow = 5;

    // The sub-region of the image to render in pixels.
    PixelBounds pixelbounds = 6;
  }

  // If true, output 16-bit floating point value when supported by the output
  // file format.
  optional bool savefp16 = 7 [default = true];

  // The type of sensor to simulate for the film.
  optional FilmSensor sensor = 8 [default = CIE_1931];

  // The film's sensitivity to light normalized to 100. This scaling is applied
  // before clamping.
  optional double iso = 9 [default = 100.0];
  
  // Clamp pixels with RGB components higher than the maximum provided.
  optional double maxcomponentvalue = 11 [default = inf];

  // If non-zero, this provides the temperature in degrees kelvin that is used
  // as the reference color temperature used for white.
  optional double whitebalance = 12 [default = 0.0];

  // The coordinate system of stored geometric data.
  enum CoordinateSystem {
    CAMERA = 0;
    WORLD = 1;
  }

  // The coordinate system to use for stored geometric data.
  optional CoordinateSystem coordinatesystem = 17 [default = CAMERA];
}

// A film which stores the rendered output as an RGB image.
message RgbFilm {
  // The output filename.
  optional string filename = 1 [default = "pbrt.exr"];

  // The size of the image in the `x` direction.
  //
  // This field has a default value of 640 in PBRTv1 and PBRTv2 and a default
  // value of 1280 in PBRTv3 and PBRTv4.
  optional uint32 xresolution = 2;

  // The size of the image in the `y` direction.
  //
  // This field has a default value of 480 in PBRTv1 and PBRTv2 and a default
  // value of 720 in PBRTv3 and PBRTv4.
  optional uint32 yresolution = 3;

  // The diagonal of the film in millimeters. Only applies if the image is
  // rendered using a realistic camera.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is not supported before PBRTv3 and should be ignored when
  //       reading earlier input.
  optional double diagonal = 4 [default = 35.0];

  // The bounds of the crop to apply to the image. If none are specified, the
  // image is uncropped.
  oneof crop_bounds {
    // The sub-region of the image to render in normalized device coordinates.
    FilmCropWindow cropwindow = 5;

    // The sub-region of the image to render in pixels.
    //
    // NOTE: For simplicity, this field is shared between all PBRT versions;
    //       however, it is only supported in PBRTv4 and should be ignored when
    //       reading earlier input.
    PixelBounds pixelbounds = 6;
  }

  // If true, output 16-bit floating point value when supported by the output
  // file format.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional bool savefp16 = 7 [default = true];

  // The type of sensor to simulate for the film.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional FilmSensor sensor = 8 [default = CIE_1931];

  // The film's sensitivity to light normalized to 100. This scaling is applied
  // before clamping.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional double iso = 9 [default = 100.0];

  // The method for using clamping the pixel values in the rendered output. If
  // none are specified than the values are left unclamped.
  oneof clamping_method {
    // Clamp pixels with luminance higher than the maximum provided.
    //
    // NOTE: For simplicity, this field is shared between all PBRT versions;
    //       however, it is only supported in PBRTv3 and should be ignored when
    //       reading all other input.  
    double maxsampleluminance = 10 [default = inf];
  
    // Clamp pixels with RGB components higher than the maximum provided.
    //
    // NOTE: For simplicity, this field is shared between all PBRT versions;
    //       however, it is only supported starting with PBRTv4 and should be
    //       ignored when reading earlier input.
    double maxcomponentvalue = 11 [default = inf];
  }

  // If non-zero, this provides the temperature in degrees kelvin that is used
  // as the reference color temperature used for white.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional double whitebalance = 12 [default = 0.0];

  // Whether or not the alpha channel of the rendered image should be
  // pre-multiplied with the RGB channels.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv1 and should be ignored when
  //       reading later input.
  optional bool premultiplyalpha = 13 [default = true];

  // The rate at which to write pixels to the output image.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv1 and should be ignored when
  //       reading later input.
  optional uint32 writefrequency = 14 [default = 4294967295];

  // If true, display the rendered image in a a window when rendering completes.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv2 and should be ignored when
  //       reading all other input.
  optional bool display = 15 [default = false];

  // A scalar output applied to the RGB output after clamping.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading all other input.
  optional double scale = 16  [default = 1.0];
}

// A film which stores the rendered output as an RGB image as well as a
// discretized spectral distribution for each pixel.
message SpectralFilm {
  // The output filename.
  optional string filename = 1 [default = "pbrt.exr"];

  // The size of the image in the `x` direction.
  optional uint32 xresolution = 2 [default = 1280];

  // The size of the image in the `y` direction.
  optional uint32 yresolution = 3 [default = 720];

  // The diagonal of the film in millimeters. Only applies if the image is
  // rendered using a realistic camera.
  optional double diagonal = 4 [default = 35.0];

  // The bounds of the crop to apply to the image. If none are specified, the
  // image is uncropped.
  oneof crop_bounds {
    // The sub-region of the image to render in normalized device coordinates.
    FilmCropWindow cropwindow = 5;

    // The sub-region of the image to render in pixels.
    PixelBounds pixelbounds = 6;
  }

  // If true, output 16-bit floating point value when supported by the output
  // file format.
  optional bool savefp16 = 7 [default = true];

  // The type of sensor to simulate for the film.
  optional FilmSensor sensor = 8 [default = CIE_1931];

  // The film's sensitivity to light normalized to 100. This scaling is applied
  // before clamping.
  optional double iso = 9 [default = 100.0];
  
  // Clamp pixels with RGB components higher than the maximum provided.
  optional double maxcomponentvalue = 11 [default = inf];

  // If non-zero, this provides the temperature in degrees kelvin that is used
  // as the reference color temperature used for white.
  optional double whitebalance = 12 [default = 0.0];

  // Number of buckets to use to store the spectral data.
  optional uint32 nbuckets = 18 [default = 16];

  // The minimum wavelength of the spectral range.  
  optional double lambdamin = 19 [default = 360.0];

  // The maximum wavelength of the spectral range.  
  optional double lambdamax = 20 [default = 830.0];
}

//
// Common Pixel Filters
//

// A pixel filter that performs a box filter.
message BoxPixelFilter {
  // The width of the filter in the x direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "xwidth".
  optional double xradius = 1 [default = 0.5];

  // The width of the filter in the y direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "ywidth".
  optional double yradius = 2 [default = 0.5];
}

// A pixel filter that performs a Gaussian filter.
message GaussianPixelFilter {
  // The width of the filter in the x direction in pixels. The default value of
  // this value changed from 2.0 to 1.5 starting with PBRTv4.
  //
  // NOTE: Prior to PBRTv4 this field was named "xwidth".
  optional double xradius = 1;

  // The width of the filter in the x direction in pixels. The default value of
  // this value changed from 2.0 to 1.5 starting with PBRTv4.
  //
  // NOTE: Prior to PBRTv4 this field was named "ywidth".
  optional double yradius = 2;

  // Standard deviation of the Gaussian distribution.
  //
  // NOTE: Prior to PBRTv4 this field was named "alpha" and was computed
  //       differently. The formula to derive `alpha` from this field is
  //       `1.0 / (2.0 * sigma * sigma).
  optional double sigma = 3 [default = 0.5];
}

// A pixel filter that performs a Lanczos filter.
message LanczosPixelFilter {
  // The width of the filter in the x direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "xwidth".
  optional double xradius = 1 [default = 4.0];

  // The width of the filter in the y direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "ywidth".
  optional double yradius = 2 [default = 4.0];

  // The extent of the sinc function in cycles before it is clamped to zero.
  optional double tau = 3 [default = 3.0];
}

// A pixel filter that performs a Mitchell-Netravali filter.
message MitchellPixelFilter {
  // The width of the filter in the x direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "xwidth".
  optional double xradius = 1 [default = 2.0];

  // The width of the filter in the y direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "ywidth".
  optional double yradius = 2 [default = 2.0];

  // The `B` parameter that controls the shape of the filter.
  optional double B = 3 [default = 0.333333333333333333];

  // The `C` parameter that controls the shape of the filter.
  optional double C = 4 [default = 0.333333333333333333];
}

// A pixel filter that performs a triangle filter.
message TrianglePixelFilter {
  // The width of the filter in the x direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "xwidth".
  optional double xradius = 1 [default = 2.0];

  // The width of the filter in the y direction in pixels.
  //
  // NOTE: Prior to PBRTv4 this field was named "ywidth".
  optional double yradius = 2 [default = 2.0];
}

//
// Common Samplers
//

// The supported randomization methods for low discrepancy samplers.
enum SamplerRandomizationMethod {
  NONE = 0;
  PERMUTEDIGITS = 1;
  OWEN = 2;
  FASTOWEN = 3;
}

// A sampler which uses the best canididate algorithm.
message BestCandidateSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 4];
}

// A low discrepancy sampler which uses a Halton sequence as its basis.
message HaltonSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1;

  // The method used to scramble the sequence to reduce the appearance of 
  // visual artifacts from poor sample selection.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional SamplerRandomizationMethod randomization = 2;

  // The seed used to scramble the distribution as part of the randomization.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional int32 seed = 3;

  // If true, samples are placed at the center of each pixel.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading all other input.
  optional bool samplepixelcenter = 8 [default = false];
}

// A sampler which uses an RNG and samples all dimensions independently.
message IndependentSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 4];

  // The seed used to initiate the RNG.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional int32 seed = 3;
}

// A low discrepancy sampler which uses a stratified Sobol sequence as its
// basis.
message PaddedSobolSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 16];

  // The method used to scramble the sequence to reduce the appearance of 
  // visual artifacts from poor sample selection.
  optional SamplerRandomizationMethod randomization = 2;

  // The seed used to scramble the distribution as part of the randomization.
  optional int32 seed = 3;
}

// A low discrepancy sampler which uses Pixar's progressive multi-jittered
// (0,2) sequence with blue noise properties as its basis
message PMJ02BNSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 16];

  // The seed used to scramble the distribution as part of the randomization.
  optional int32 seed = 3;
}

// A low discrepancy sampler which uses a Sobol sequence as its basis.
message SobolSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 16];

  // The method used to scramble the sequence to reduce the appearance of 
  // visual artifacts from poor sample selection.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional SamplerRandomizationMethod randomization = 2;

  // The seed used to scramble the distribution as part of the randomization.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional int32 seed = 3;
}

// A sampler which stratifies samples generated by an RNG.
message StratifiedSampler {
  // The seed used to initiate the RNG.
  //
  // NOTE: For simplicity, this field is shared between all PBRT versions;
  //       however, it is only supported starting with PBRTv4 and should be
  //       ignored when reading earlier input.
  optional int32 seed = 3;

  // The maximum number of sampled dimensions before falling back to an RNG.
  //
  // NOTE: For simplicity, this field is shared across multiple PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading input from other versions.
  optional uint32 dimensions = 4 [default = 4];

  // The number of samples in the image `x` axis.
  optional uint32 xsamples = 5;

  // The number of samples in the image `y` axis.
  optional uint32 ysamples = 6;

  // If true, the samples are jittered based on the RNG.
  optional bool jitter = 7 [default = true];
}

// A low discrepancy sampler which uses a Sobol sequence with blue noise as its
// basis.
message ZSobolSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1 [default = 16];

  // The method used to scramble the sequence to reduce the appearance of 
  // visual artifacts from poor sample selection.
  optional SamplerRandomizationMethod randomization = 2;

  // The seed used to scramble the distribution as part of the randomization.
  optional int32 seed = 3;
}

message ZeroTwoSequenceSampler {
  // The number of samples to do per pixel.
  optional uint32 pixelsamples = 1;

  // The maximum number of sampled dimensions before falling back to an RNG.
  //
  // NOTE: For simplicity, this field is shared across multiple PBRT versions;
  //       however, it is only supported in PBRTv3 and should be ignored when
  //       reading input from other versions.
  optional uint32 dimensions = 4 [default = 4];
}
